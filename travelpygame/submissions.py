"""Classes for storing rounds and submissions in a generic way. I should think of a better name at some point, and also document the format outside of just source code comments (even if it's just autogenerated)"""

import asyncio
import re
from collections.abc import Sequence
from enum import StrEnum
from pathlib import Path
from typing import Any

from aiohttp import ClientSession
from pydantic import BaseModel, TypeAdapter
from tqdm.auto import tqdm

from travelpygame import tpg_api
from travelpygame.util.kml import Placemark, SubmissionTracker, parse_submission_kml


class Submission(BaseModel, extra='allow'):
	name: str
	"""Name of whoever submitted this."""
	latitude: float
	"""WGS84 latitude of the picture."""
	longitude: float
	"""WGS84 longitude of the picture."""
	is_5k: bool | None = None
	"""Whether this submission counted as a 5K or not, or None if unknown."""
	is_antipode_5k: bool | None = None
	"""Whether this submission counted as a 5K for the antipode or not."""
	is_tie: bool
	"""Whether this submission should be considered to be a tie with other pics nearby that also have is_tie = True."""


class TPGType(StrEnum):
	Normal = 'normal'
	"""Standard TPG where you have one target per round and one submission"""
	# Anything else like multi (increasing) or line once I implement stuff like that


class Round(BaseModel, extra='allow'):
	name: str | None
	"""Round name, if applicable."""
	type: TPGType = TPGType.Normal
	"""For nowâ€¦"""
	number: int
	season: int | None = None
	country_code: str | None = None
	"""Country code, if applicable/known beforehand."""
	latitude: float
	longitude: float
	submissions: list[Submission]


def _convert_submission(
	sub: tpg_api.TPGSubmission, players: dict[str, tpg_api.TPGPlayer]
) -> Submission:
	extra = {'id': sub.id, 'discord_id': sub.discord_id}
	if sub.discord_id in players:
		player = players[sub.discord_id]
		name = player.name
		extra['username'] = player.username
	else:
		# That will have to do
		name = sub.discord_id
	return Submission(
		name=name,
		latitude=sub.latitude,
		longitude=sub.longitude,
		is_5k=sub.fivek,
		is_antipode_5k=sub.antipode_5k,
		is_tie=sub.is_tie,
		**extra,
	)


async def get_main_tpg_rounds(session: ClientSession | None = None) -> list[Round]:
	if session is None:
		async with ClientSession() as sesh:
			return await get_main_tpg_rounds(sesh)

	api_rounds = await tpg_api.get_rounds(session)
	players = {player.discord_id: player for player in await tpg_api.get_players(session)}

	rounds: list[Round] = []

	with tqdm(api_rounds, 'Getting submissions', unit='round') as t:
		for round_ in t:
			api_subs = await tpg_api.get_round_submissions(round_.number, session)
			subs = [_convert_submission(sub, players) for sub in api_subs]
			name = f'R{round_.number}: {round_.country}' if round_.country else f'R{round_.number}'
			if round_.water:
				name += ' (water)'
			extra: dict[str, Any] = {'is_water': round_.water}
			if round_.start_timestamp:
				extra['start_date'] = round_.start_timestamp
			if round_.end_timestamp:
				extra['end_date'] = round_.end_timestamp
			rounds.append(
				Round(
					name=name,
					number=round_.number,
					season=round_.season,
					country_code=round_.country,
					latitude=round_.latitude,
					longitude=round_.longitude,
					submissions=subs,
					**extra,
				)
			)

	return rounds


round_list_adapter = TypeAdapter(list[Round])


async def get_main_tpg_rounds_with_path(
	path: Path | None = None, session: ClientSession | None = None
) -> list[Round]:
	if path:
		try:
			content = await asyncio.to_thread(path.read_bytes)
			return round_list_adapter.validate_json(content)
		except FileNotFoundError:
			pass
	rounds = await get_main_tpg_rounds(session)
	if path:
		j = round_list_adapter.dump_json(rounds, indent=4, exclude_none=True)
		await asyncio.to_thread(path.write_bytes, j)
	return rounds


def _convert_submission_from_tracker(sub: Placemark) -> Submission:
	extra = {'description': sub.description, 'style': sub.style}
	return Submission(
		name=sub.name,
		latitude=sub.point.y,
		longitude=sub.point.x,
		is_tie=False,
		**extra,  # pyright: ignore[reportArgumentType] #Pylance does not know how pydantic extra works, it seems
	)


def _find_season(season_starts: list[int], round_number: int) -> int:
	if 1 not in season_starts:
		season_starts.append(1)
	season_starts = sorted(season_starts, reverse=True)
	for season, season_start in enumerate(season_starts):
		if round_number >= season_start:
			return (len(season_starts) - season) - 1
	return 0


def convert_submission_tracker(
	tracker: Path | Sequence[Path] | SubmissionTracker, season: int | list[int] | None = None
) -> list[Round]:
	"""Converts a submission tracker (paths to .kml file(s), or a SubmissionTracker already parsed from such) to this more consistent format.

	Arguments:
		season: If a list, this is a list of starting rounds for each season (assumes there is a season zero, not because I can't be bothered handling one-based indexing, but because most spinoffs have a pilot).
	"""
	if not isinstance(tracker, SubmissionTracker):
		tracker = parse_submission_kml(tracker)

	rounds: list[Round] = []
	for i, tracker_round in enumerate(tracker.rounds, 1):
		round_season = _find_season(season, i) if isinstance(season, list) else season
		# TODO: Any scenario where is_tie would be considered True, eventually we might need to implement that
		subs = [_convert_submission_from_tracker(sub) for sub in tracker_round.submissions]
		rounds.append(
			Round(
				name=tracker_round.name,
				number=i,
				season=round_season,
				latitude=tracker_round.target.y,
				longitude=tracker_round.target.x,
				submissions=subs,
			)
		)
	return rounds


def load_rounds(path: Path) -> list[Round]:
	content = path.read_bytes()
	return round_list_adapter.validate_json(content)


async def load_rounds_async(path: Path) -> list[Round]:
	content = await asyncio.to_thread(path.read_bytes)
	return round_list_adapter.validate_json(content)


def _spaces_to_tabs(m: re.Match[str]):
	"""Whoa look out controversial opinion coming through"""
	return '\n' + m[1].replace('  ', '\t')


def rounds_to_json(rounds: list[Round]) -> str:
	json_bytes = round_list_adapter.dump_json(rounds, indent=2, exclude_none=True)
	return re.sub(r'\n(\s{2,})', _spaces_to_tabs, json_bytes.decode('utf-8'))
