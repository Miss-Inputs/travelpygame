"""Classes for storing rounds and submissions in a generic way. I should think of a better name at some point, and also document the format outside of just source code comments (even if it's just autogenerated)"""

import asyncio
import contextlib
import re
from collections import Counter, defaultdict
from collections.abc import Iterable, Sequence
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any

import geopandas
import pandas
import shapely
from pydantic import BaseModel, TypeAdapter
from shapely import Point
from tqdm.auto import tqdm

from travelpygame import tpg_api

from .util.io_utils import load_points
from .util.kml import Placemark, SubmissionTracker, parse_submission_kml

if TYPE_CHECKING:
	from aiohttp import ClientSession

PlayerName = str
"""Type hint for what is a player name. Should be consistent."""


class Submission(BaseModel, extra='allow'):
	name: PlayerName
	"""Name of whoever submitted this."""
	latitude: float
	"""WGS84 latitude of the picture."""
	longitude: float
	"""WGS84 longitude of the picture."""
	description: str | None = None
	"""Some kind of description of the picture/location if we have one."""
	is_5k: bool | None = None
	"""Whether this submission counted as a 5K or not, or None if unknown."""
	is_antipode_5k: bool | None = None
	"""Whether this submission counted as a 5K for the antipode or not."""
	is_tie: bool = False
	"""Whether this submission should be considered to be a tie with other pics nearby that also have is_tie = True."""

	score: float | None = None
	"""Score for this submission, or None if score is not calculated yet."""
	rank: int | None = None
	"""Placement for this submission, starting at 1 for first place and 2 for second, etc, or None if score is not calculated yet."""
	distance: float | None = None
	"""Distance for this submission in metres from the target, or None if this is not calculated yet."""

	@property
	def point(self) -> Point:
		return Point(self.longitude, self.latitude)


class TPGType(StrEnum):
	Normal = 'normal'
	"""Standard TPG where you have one target per round and one submission."""
	# Anything else like multi (increasing) or line once I implement stuff like that


class RoundInfo(BaseModel, extra='allow'):
	"""I really am bad at naming things. This is Round but without the submissions"""

	name: str | None
	"""Round name, if applicable."""
	type: TPGType = TPGType.Normal
	"""For now…"""
	number: int
	season: int | None = None
	country_code: str | None = None
	"""Country code, if applicable/known beforehand."""
	latitude: float
	"""Latitude of round target."""
	longitude: float
	"""Longitude of round target."""

	@property
	def target(self) -> Point:
		return Point(self.longitude, self.latitude)


class Round(RoundInfo):
	"""A round + its submissions, which may or may not be scored."""

	submissions: list[Submission]

	@property
	def is_scored(self) -> bool:
		"""Returns true iff _all_ submissions are scored."""
		return all(sub.score is not None for sub in self.submissions)

	def find_player(self, name: str) -> Submission | None:
		"""Finds the submission of a player (case-sensitive, etc), or returns None if that player does not have a submission for this round."""
		return next((sub for sub in self.submissions if sub.name == name), None)


class ScoringOptions(BaseModel, extra='allow'):
	"""Different ways to score TPG. This is not an exhaustive set of configurations, but it's what we use at the moment"""

	fivek_flat_score: float | None
	"""If not None, 5Ks have a constant score of this"""
	fivek_bonus: float | None
	"""If not None, add this amount to the score of any submission which is a 5K (note that this would be in conjunction with rank_bonus)"""
	rank_bonuses: dict[int, float] | None
	"""If not none, add amounts to the score of players receiving a certain rank, e.g. main TPG uses {1: 3000, 2: 2000, 1: 1000}"""
	antipode_5k_flat_score: float | None
	"""If not None, antipode 5Ks have a constant score of this"""
	world_distance_km: float = 20_000
	"""Maximum distance (size of what is considered the entire world), usually simplified as 20,000 for world TPG or 5,000 for most regional TPGs"""
	round_to: int | None = 2
	"""Round score to this many decimal places, or None to not do that"""
	distance_divisor: float | None = None
	"""If not None, divide distance by this, and then subtract from (world_distance_km / 4) (this is basically just for main TPG)"""
	clip_negative: bool = True
	"""Sets negative distance scores to 0, you probably want this in regional TPGs to be nice to players who are outside your region but submit anyway for the love of the game (so they can get points from rank instead)"""
	average_distance_and_rank: bool = True
	"""If true, score is (distance score + rank score) / 2, if false (as with main TPG), just add the two score parts together"""


class Season(BaseModel, extra='allow'):
	"""Stores a list of rounds and their submissions, and the rules for scoring. Not used just yet."""

	name: str
	"""Name of the spinoff, or "Main", etc"""
	number: int | None
	type: TPGType
	scoring: ScoringOptions
	"""Specifies how this season is scored."""
	rounds: list[Round]
	"""All rounds that have happened so far in this season."""


def _convert_submission(
	sub: tpg_api.TPGSubmission, players: dict[str, tpg_api.TPGPlayer]
) -> Submission:
	extra = {'id': sub.id, 'discord_id': sub.discord_id, 'game': sub.game}
	if sub.discord_id in players:
		player = players[sub.discord_id]
		name = player.name
		extra['username'] = player.username
	else:
		# That will have to do
		name = sub.discord_id
	return Submission(
		name=name,
		latitude=sub.latitude,
		longitude=sub.longitude,
		is_5k=sub.fivek,
		is_antipode_5k=sub.antipode_5k,
		is_tie=sub.is_tie,
		**extra,
	)


async def get_main_tpg_rounds(game: int = 1, session: 'ClientSession | None' = None) -> list[Round]:
	if session is None:
		async with tpg_api.get_session() as sesh:
			return await get_main_tpg_rounds(game, sesh)

	api_rounds = await tpg_api.get_rounds(game, session)
	players = {player.discord_id: player for player in await tpg_api.get_players(session)}

	rounds: list[Round] = []

	with tqdm(api_rounds, 'Getting submissions', unit='round') as t:
		for round_ in t:
			api_subs = await tpg_api.get_round_submissions(round_.number, game, session)
			subs = [_convert_submission(sub, players) for sub in api_subs]
			name = f'R{round_.number}: {round_.country}' if round_.country else f'R{round_.number}'
			if round_.water:
				name += ' (water)'
			extra: dict[str, Any] = {'is_water': round_.water, 'game': round_.game}
			if round_.start_timestamp:
				extra['start_date'] = round_.start_timestamp
			if round_.end_timestamp:
				extra['end_date'] = round_.end_timestamp
			rounds.append(
				Round(
					name=name,
					number=round_.number,
					season=round_.season,
					country_code=round_.country,
					latitude=round_.latitude,
					longitude=round_.longitude,
					submissions=subs,
					**extra,
				)
			)

	return rounds


round_list_adapter = TypeAdapter(list[Round])


async def get_main_tpg_rounds_with_path(
	path: Path | None = None, game: int = 1, session: 'ClientSession | None' = None
) -> list[Round]:
	if path:
		try:
			content = await asyncio.to_thread(path.read_bytes)
			return round_list_adapter.validate_json(content)
		except FileNotFoundError:
			pass
	rounds = await get_main_tpg_rounds(game, session)
	if path:
		j = round_list_adapter.dump_json(rounds, indent=4, exclude_none=True)
		await asyncio.to_thread(path.write_bytes, j)
	return rounds


def _convert_submission_from_tracker(sub: Placemark, fivek_suffix: str | None = None) -> Submission:
	extra = {}
	if sub.style:
		style_match = re.match(r'#(icon-.+?)-(.+?)-(.+)', sub.style)
		if style_match is None:
			extra['style'] = sub.style
		else:
			# Mind you, this is not the actual <Icon> tag in the thing, I'm not sure if that would be more useful
			extra['icon'] = style_match[1]
			extra['colour'] = style_match[2]
			extra['style'] = style_match[3]  # labelson, nodesc, etc

	is_5k = None
	name = sub.name
	if fivek_suffix is not None and name.endswith(fivek_suffix):
		name = name.removesuffix(fivek_suffix)
		is_5k = True

	return Submission(
		name=name,
		latitude=sub.point.y,
		longitude=sub.point.x,
		description=sub.description,
		is_5k=is_5k,
		**extra,  # pyright: ignore[reportArgumentType] #Pylance does not know how pydantic extra works, it seems
	)


def _find_season(season_starts: list[int], round_number: int) -> int:
	if 1 not in season_starts:
		season_starts.append(1)
	season_starts = sorted(season_starts, reverse=True)
	for season, season_start in enumerate(season_starts):
		if round_number >= season_start:
			return (len(season_starts) - season) - 1
	return 0


def convert_submission_tracker(
	tracker: Path | Sequence[Path] | SubmissionTracker,
	start_round: int = 1,
	season: int | list[int] | None = None,
	fivek_suffix: str | None = None,
) -> list[Round]:
	"""Converts a submission tracker (paths to .kml file(s), or a SubmissionTracker already parsed from such) to this more consistent format.

	Arguments:
		season: If a list, this is a list of starting rounds for each season (assumes there is a season zero, not because I can't be bothered handling one-based indexing, but because most spinoffs have a pilot).
		fivek_suffix: Optional string to put on the end of submission names to mark them manually as a 5K.
	"""
	if not isinstance(tracker, SubmissionTracker):
		tracker = parse_submission_kml(tracker)

	rounds: list[Round] = []
	for i, tracker_round in enumerate(tracker.rounds, start_round):
		round_season = _find_season(season, i) if isinstance(season, list) else season
		# TODO: Any scenario where is_tie would be considered True, eventually we might need to implement that
		# TODO: Ensure that there are no duplicate names
		subs = [
			_convert_submission_from_tracker(sub, fivek_suffix) for sub in tracker_round.submissions
		]
		rounds.append(
			Round(
				name=tracker_round.name,
				number=i,
				season=round_season,
				latitude=tracker_round.target.y,
				longitude=tracker_round.target.x,
				submissions=subs,
			)
		)
	return rounds


def load_rounds(path: Path) -> list[Round]:
	"""Loads a list of rounds from a JSON file."""
	content = path.read_bytes()
	return round_list_adapter.validate_json(content)


async def load_rounds_async(path: Path) -> list[Round]:
	"""Loads a list of rounds from a JSON file in another thread."""
	content = await asyncio.to_thread(path.read_bytes)
	return round_list_adapter.validate_json(content)


def _spaces_to_tabs(m: re.Match[str]):
	"""Whoa look out controversial opinion coming through"""
	return '\n' + m[1].replace('  ', '\t')


def rounds_to_json(rounds: list[Round]) -> str:
	"""Converts a list of rounds to nicely formatted JSON."""
	json_bytes = round_list_adapter.dump_json(rounds, indent=2, exclude_none=True)
	return re.sub(r'\n(\s{2,})', _spaces_to_tabs, json_bytes.decode('utf-8'))


async def get_main_tpg_submissions_per_user(
	rounding: int = 6, session: 'ClientSession | None' = None
) -> dict[str, geopandas.GeoSeries]:
	"""Fetches submissions per-user from the API.

	Returns:
		dict: {player name: point set}"""
	if session is None:
		async with tpg_api.get_session() as sesh:
			return await get_main_tpg_submissions_per_user(rounding, sesh)
	per_user_subs: defaultdict[str, list[tuple[float, float]]] = defaultdict(list)

	with tqdm(desc='Getting submissions', unit='submission') as t:
		games = await tpg_api.get_games(session)
		for game in games:
			rounds = await tpg_api.get_rounds(game.id, session)
			for r in rounds:
				subs = await tpg_api.get_round_submissions(r.number, game.id, session)
				for sub in subs:
					t.update()
					per_user_subs[sub.discord_id].append((sub.latitude, sub.longitude))

	player_names = {player.discord_id: player.name for player in await tpg_api.get_players(session)}
	out: dict[str, geopandas.GeoSeries] = {}
	for player_id, latlngs in per_user_subs.items():
		# Avoid duplicating points that are only off in the 7th decimal place or whatever
		points: dict[tuple[float, float], Point] = {}
		for lat, lng in latlngs:
			points[round(lat, rounding), round(lng, rounding)] = Point(lng, lat)
		player_name = player_names.get(player_id, player_id)
		out[player_name] = geopandas.GeoSeries(list(points.values()), crs='wgs84')
	return out


def get_submissions_per_user_from_path(path: Path):
	"""Gets submissions per user either from a JSON file containing TPG data, or from a geofile containing submissions with a "player" column (and optionally a "name" column for the picture description.)"""
	subs: dict[str, geopandas.GeoSeries] = {}
	if path.suffix[1:].lower() == 'json':
		rounds = load_rounds(path)
		for player, latlngs in get_submissions_per_user(rounds).items():
			player_points = shapely.points([(lng, lat) for lat, lng in latlngs]).tolist()
			assert not isinstance(player_points, Point)
			subs[player] = geopandas.GeoSeries(player_points, crs='wgs84', name=player)
	else:
		points = load_points(path)
		for player, group in points.groupby('player', sort=False):
			name_col = group.get('name')
			if name_col is not None and name_col.is_unique and not name_col.hasnans:
				with contextlib.suppress(ValueError):
					group = group.set_index('name', verify_integrity=True)
			else:
				group = group.reset_index()
			if not isinstance(group, geopandas.GeoDataFrame):
				raise TypeError(
					f'Encountered {type(group)} when grouping instead of GeoDataFrame for {player}'
				)
			subs[str(player)] = group.geometry.rename(str(player))
	return subs


async def get_submissions_per_user_with_path(
	path: Path | None = None, session: 'ClientSession | None' = None
) -> dict[str, geopandas.GeoSeries]:
	"""If path is a geofile, it _must_ have a column named "player" with the player name of each point, and if it has a column named "name" that is unique for each player then that will be used as the name of each pic (the index in the GeoSeries). Otherwise, it will load TPG data from that file. If path does not exist, it will fetch data from the API and save it there."""
	if path:
		try:
			return await asyncio.to_thread(get_submissions_per_user_from_path, path)
		except FileNotFoundError:
			pass

	subs = await get_main_tpg_submissions_per_user(session=session)
	if path and path.suffix[1:].lower() != 'json':
		all_subs = pandas.concat(
			(
				geopandas.GeoDataFrame(
					pandas.Series(player, points.index, name='player'), geometry=points
				)
				for player, points in subs.items()
			),
			ignore_index=True,
		)
		assert isinstance(all_subs, geopandas.GeoDataFrame)
		await asyncio.to_thread(all_subs.to_file, path)
	return subs


def get_submissions_per_user(rounds: Iterable[Round]):
	"""Returns dict of player name -> set[(lat, lng)] from TPG data. Probably doesn't need to be used anymore."""
	# TODO: Redo this so we can more properly round coordinates, and potentially get sub.description as the name (but it would have to be filled in with format_point as a placeholder if returning a GeoSeries… hrm)
	submissions: defaultdict[str, set[tuple[float, float]]] = defaultdict(set)

	for r in rounds:
		for sub in r.submissions:
			submissions[sub.name].add((sub.latitude, sub.longitude))
	return submissions


_CombinationSource = Round | Season | tuple[PlayerName, float, float]


def _add_combined_subs(
	d: dict[PlayerName, Counter[Point]],
	source: _CombinationSource,
	aliases: dict[str, PlayerName],
	rounding: int,
):
	if isinstance(source, Round):
		for sub in source.submissions:
			_add_combined_subs(d, (sub.name, sub.latitude, sub.longitude), aliases, rounding)
	elif isinstance(source, Season):
		for roundyboi in source.rounds:
			_add_combined_subs(d, roundyboi, aliases, rounding)
	else:
		player, lat, lng = source
		player = aliases.get(player, player)
		point = Point(round(lng, rounding), round(lat, rounding))
		d.setdefault(player, Counter())[point] += 1


def combine_player_submissions(
	sources: Iterable[_CombinationSource], aliases: dict[str, PlayerName] | None, rounding: int = 6
) -> dict[PlayerName, geopandas.GeoDataFrame]:
	"""Combines rounds with submissions/mappings of player name + coordinates into one mapping of submissions by player.

	Arguments:
		aliases: Optional mapping of {raw player name -> player name}, for spelling variations in trackers and such.
		rounding: Number of decimal places to round to.

	Returns:
	        dict containing player submissions by name."""
	# TODO: Probably should ensure player name is case insensitive or whatnot, though just need to ensure it still ends up the correct way

	combined: dict[PlayerName, Counter[Point]] = {}
	for source in sources:
		_add_combined_subs(combined, source, aliases or {}, rounding)
	frames: dict[PlayerName, geopandas.GeoDataFrame] = {}
	for player, points in frames.items():
		point_counts = [{'point': point, 'count': count} for point, count in points.items()]
		frames[player] = geopandas.GeoDataFrame(point_counts, geometry='point', crs='wgs84')
	return frames
