"""Classes for storing rounds and submissions in a generic way. I should think of a better name at some point, and also document the format outside of just source code comments (even if it's just autogenerated)"""

import asyncio
import contextlib
import re
from collections import defaultdict
from collections.abc import Iterable, Sequence
from enum import StrEnum
from pathlib import Path
from typing import TYPE_CHECKING, Any

import geopandas
import pandas
import shapely
from pydantic import BaseModel, TypeAdapter
from shapely import Point
from tqdm.auto import tqdm

from travelpygame import tpg_api

from .util.io_utils import load_points
from .util.kml import Placemark, SubmissionTracker, parse_submission_kml

if TYPE_CHECKING:
	from aiohttp import ClientSession


class Submission(BaseModel, extra='allow'):
	name: str
	"""Name of whoever submitted this."""
	latitude: float
	"""WGS84 latitude of the picture."""
	longitude: float
	"""WGS84 longitude of the picture."""
	description: str | None = None
	"""Some kind of description of the picture/location if we have one."""
	is_5k: bool | None = None
	"""Whether this submission counted as a 5K or not, or None if unknown."""
	is_antipode_5k: bool | None = None
	"""Whether this submission counted as a 5K for the antipode or not."""
	is_tie: bool = False
	"""Whether this submission should be considered to be a tie with other pics nearby that also have is_tie = True."""

	score: float | None = None
	"""Score for this submission, or None if score is not calculated yet."""
	rank: int | None = None
	"""Placement for this submission, starting at 1 for first place and 2 for second, etc, or None if score is not calculated yet."""
	distance: float | None = None
	"""Distance for this submission in metres from the target, or None if this is not calculated yet."""

	@property
	def point(self) -> Point:
		return Point(self.longitude, self.latitude)


class TPGType(StrEnum):
	Normal = 'normal'
	"""Standard TPG where you have one target per round and one submission"""
	# Anything else like multi (increasing) or line once I implement stuff like that


class RoundInfo(BaseModel, extra='allow'):
	"""I really am bad at naming things. This is Round but without the submissions"""

	name: str | None
	"""Round name, if applicable."""
	type: TPGType = TPGType.Normal
	"""For now…"""
	number: int
	season: int | None = None
	country_code: str | None = None
	"""Country code, if applicable/known beforehand."""
	latitude: float
	"""Latitude of round target."""
	longitude: float
	"""Longitude of round target."""

	@property
	def target(self) -> Point:
		return Point(self.longitude, self.latitude)


class Round(RoundInfo):
	submissions: list[Submission]

	@property
	def is_scored(self) -> bool:
		return all(sub.score is not None for sub in self.submissions)

	def find_player(self, name: str):
		return next((sub for sub in self.submissions if sub.name == name), None)


def _convert_submission(
	sub: tpg_api.TPGSubmission, players: dict[str, tpg_api.TPGPlayer]
) -> Submission:
	extra = {'id': sub.id, 'discord_id': sub.discord_id, 'game': sub.game}
	if sub.discord_id in players:
		player = players[sub.discord_id]
		name = player.name
		extra['username'] = player.username
	else:
		# That will have to do
		name = sub.discord_id
	return Submission(
		name=name,
		latitude=sub.latitude,
		longitude=sub.longitude,
		is_5k=sub.fivek,
		is_antipode_5k=sub.antipode_5k,
		is_tie=sub.is_tie,
		**extra,
	)


async def get_main_tpg_rounds(game: int = 1, session: 'ClientSession | None' = None) -> list[Round]:
	if session is None:
		async with tpg_api.get_session() as sesh:
			return await get_main_tpg_rounds(game, sesh)

	api_rounds = await tpg_api.get_rounds(game, session)
	players = {player.discord_id: player for player in await tpg_api.get_players(session)}

	rounds: list[Round] = []

	with tqdm(api_rounds, 'Getting submissions', unit='round') as t:
		for round_ in t:
			api_subs = await tpg_api.get_round_submissions(round_.number, game, session)
			subs = [_convert_submission(sub, players) for sub in api_subs]
			name = f'R{round_.number}: {round_.country}' if round_.country else f'R{round_.number}'
			if round_.water:
				name += ' (water)'
			extra: dict[str, Any] = {'is_water': round_.water, 'game': round_.game}
			if round_.start_timestamp:
				extra['start_date'] = round_.start_timestamp
			if round_.end_timestamp:
				extra['end_date'] = round_.end_timestamp
			rounds.append(
				Round(
					name=name,
					number=round_.number,
					season=round_.season,
					country_code=round_.country,
					latitude=round_.latitude,
					longitude=round_.longitude,
					submissions=subs,
					**extra,
				)
			)

	return rounds


round_list_adapter = TypeAdapter(list[Round])


async def get_main_tpg_rounds_with_path(
	path: Path | None = None, game: int = 1, session: 'ClientSession | None' = None
) -> list[Round]:
	if path:
		try:
			content = await asyncio.to_thread(path.read_bytes)
			return round_list_adapter.validate_json(content)
		except FileNotFoundError:
			pass
	rounds = await get_main_tpg_rounds(game, session)
	if path:
		j = round_list_adapter.dump_json(rounds, indent=4, exclude_none=True)
		await asyncio.to_thread(path.write_bytes, j)
	return rounds


def _convert_submission_from_tracker(sub: Placemark) -> Submission:
	extra = {}
	if sub.style:
		style_match = re.match(r'#(icon-.+?)-(.+?)-(.+)', sub.style)
		if style_match is None:
			extra['style'] = sub.style
		else:
			# Mind you, this is not the actual <Icon> tag in the thing, I'm not sure if that would be more useful
			extra['icon'] = style_match[1]
			extra['colour'] = style_match[2]
			extra['style'] = style_match[3]  # labelson, nodesc, etc

	return Submission(
		name=sub.name,
		latitude=sub.point.y,
		longitude=sub.point.x,
		description=sub.description,
		**extra,  # pyright: ignore[reportArgumentType] #Pylance does not know how pydantic extra works, it seems
	)


def _find_season(season_starts: list[int], round_number: int) -> int:
	if 1 not in season_starts:
		season_starts.append(1)
	season_starts = sorted(season_starts, reverse=True)
	for season, season_start in enumerate(season_starts):
		if round_number >= season_start:
			return (len(season_starts) - season) - 1
	return 0


def convert_submission_tracker(
	tracker: Path | Sequence[Path] | SubmissionTracker,
	start_round: int = 1,
	season: int | list[int] | None = None,
) -> list[Round]:
	"""Converts a submission tracker (paths to .kml file(s), or a SubmissionTracker already parsed from such) to this more consistent format.

	Arguments:
		season: If a list, this is a list of starting rounds for each season (assumes there is a season zero, not because I can't be bothered handling one-based indexing, but because most spinoffs have a pilot).
	"""
	if not isinstance(tracker, SubmissionTracker):
		tracker = parse_submission_kml(tracker)

	rounds: list[Round] = []
	for i, tracker_round in enumerate(tracker.rounds, start_round):
		round_season = _find_season(season, i) if isinstance(season, list) else season
		# TODO: Any scenario where is_tie would be considered True, eventually we might need to implement that
		# TODO: Ensure that there are no duplicate names
		subs = [_convert_submission_from_tracker(sub) for sub in tracker_round.submissions]
		rounds.append(
			Round(
				name=tracker_round.name,
				number=i,
				season=round_season,
				latitude=tracker_round.target.y,
				longitude=tracker_round.target.x,
				submissions=subs,
			)
		)
	return rounds


def load_rounds(path: Path) -> list[Round]:
	"""Loads a list of rounds from a JSON file."""
	content = path.read_bytes()
	return round_list_adapter.validate_json(content)


async def load_rounds_async(path: Path) -> list[Round]:
	"""Loads a list of rounds from a JSON file in another thread."""
	content = await asyncio.to_thread(path.read_bytes)
	return round_list_adapter.validate_json(content)


def _spaces_to_tabs(m: re.Match[str]):
	"""Whoa look out controversial opinion coming through"""
	return '\n' + m[1].replace('  ', '\t')


def rounds_to_json(rounds: list[Round]) -> str:
	"""Converts a list of rounds to nicely formatted JSON."""
	json_bytes = round_list_adapter.dump_json(rounds, indent=2, exclude_none=True)
	return re.sub(r'\n(\s{2,})', _spaces_to_tabs, json_bytes.decode('utf-8'))


async def get_main_tpg_submissions_per_user(
	rounding: int = 6, session: 'ClientSession | None' = None
) -> dict[str, geopandas.GeoSeries]:
	"""Fetches submissions per-user from the API.

	Returns:
		dict: {player name: point set}"""
	if session is None:
		async with tpg_api.get_session() as sesh:
			return await get_main_tpg_submissions_per_user(rounding, sesh)
	per_user_subs: defaultdict[str, list[tuple[float, float]]] = defaultdict(list)

	with tqdm(desc='Getting submissions', unit='submission') as t:
		games = await tpg_api.get_games(session)
		for game in games:
			rounds = await tpg_api.get_rounds(game.id, session)
			for r in rounds:
				subs = await tpg_api.get_round_submissions(r.number, game.id, session)
				for sub in subs:
					t.update()
					per_user_subs[sub.discord_id].append((sub.latitude, sub.longitude))

	player_names = {player.discord_id: player.name for player in await tpg_api.get_players(session)}
	out: dict[str, geopandas.GeoSeries] = {}
	for player_id, latlngs in per_user_subs.items():
		# Avoid duplicating points that are only off in the 7th decimal place or whatever
		points: dict[tuple[float, float], Point] = {}
		for lat, lng in latlngs:
			points[round(lat, rounding), round(lng, rounding)] = Point(lng, lat)
		player_name = player_names.get(player_id, player_id)
		out[player_name] = geopandas.GeoSeries(list(points.values()), crs='wgs84')
	return out


def get_submissions_per_user_from_path(path: Path):
	"""Gets submissions per user either from a JSON file containing TPG data, or from a geofile containing submissions with a "player" column (and optionally a "name" column for the picture description.)"""
	subs: dict[str, geopandas.GeoSeries] = {}
	if path.suffix[1:].lower() == 'json':
		rounds = load_rounds(path)
		for player, latlngs in get_submissions_per_user(rounds).items():
			player_points = shapely.points([(lng, lat) for lat, lng in latlngs]).tolist()
			assert not isinstance(player_points, Point)
			subs[player] = geopandas.GeoSeries(player_points, crs='wgs84', name=player)
	else:
		points = load_points(path)
		for player, group in points.groupby('player', sort=False):
			name_col = group.get('name')
			if name_col is not None and name_col.is_unique and not name_col.hasnans:
				with contextlib.suppress(ValueError):
					group = group.set_index('name', verify_integrity=True)
			else:
				group = group.reset_index()
			if not isinstance(group, geopandas.GeoDataFrame):
				raise TypeError(
					f'Encountered {type(group)} when grouping instead of GeoDataFrame for {player}'
				)
			subs[str(player)] = group.geometry.rename(str(player))
	return subs


async def get_submissions_per_user_with_path(
	path: Path | None = None, session: 'ClientSession | None' = None
) -> dict[str, geopandas.GeoSeries]:
	"""If path is a geofile, it _must_ have a column named "player" with the player name of each point, and if it has a column named "name" that is unique for each player then that will be used as the name of each pic (the index in the GeoSeries). Otherwise, it will load TPG data from that file. If path does not exist, it will fetch data from the API and save it there."""
	if path:
		try:
			return await asyncio.to_thread(get_submissions_per_user_from_path, path)
		except FileNotFoundError:
			pass

	subs = await get_main_tpg_submissions_per_user(session=session)
	if path and path.suffix[1:].lower() != 'json':
		all_subs = pandas.concat(
			(
				geopandas.GeoDataFrame(
					pandas.Series(player, points.index, name='player'), geometry=points
				)
				for player, points in subs.items()
			),
			ignore_index=True,
		)
		assert isinstance(all_subs, geopandas.GeoDataFrame)
		await asyncio.to_thread(all_subs.to_file, path)
	return subs


def get_submissions_per_user(rounds: Iterable[Round]):
	"""Returns dict of player name -> set[(lat, lng)] from TPG data. Probably doesn't need to be used anymore."""
	# TODO: Redo this so we can more properly round coordinates, and potentially get sub.description as the name (but it would have to be filled in with format_point as a placeholder if returning a GeoSeries… hrm)
	submissions: defaultdict[str, set[tuple[float, float]]] = defaultdict(set)

	for r in rounds:
		for sub in r.submissions:
			submissions[sub.name].add((sub.latitude, sub.longitude))
	return submissions
